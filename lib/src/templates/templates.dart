/// Describes a template available for feature generation.
class TemplateInfo {
  final String name;
  final String description;
  const TemplateInfo(this.name, this.description);
}

/// Built-in templates shipped with the package.
const availableTemplates = <TemplateInfo>[
  TemplateInfo('default',
      'Full Clean Architecture: data/domain/presentation with Cubit and GetIt hooks'),
  TemplateInfo(
      'minimal', 'Minimal skeleton: entities, usecases, cubit, and a page'),
];

/// Converts a string like `user_profile` or `user-profile` to `UserProfile`.
String toPascalCase(String text) {
  return text
      .split(RegExp(r'[_\-\s]+'))
      .where((w) => w.isNotEmpty)
      .map((w) => w[0].toUpperCase() + w.substring(1))
      .join();
}

/// Returns a file map for the "default" template of [feature].
///
/// Keys are relative file paths under the feature directory; values are file
/// contents.
Map<String, String> defaultTemplateFiles(String feature) {
  final pascal = toPascalCase(feature);
  return {
    'domain/entities/${feature}_entity.dart':
        'class ${pascal}Entity { const ${pascal}Entity(); }\n',
    'domain/repositories/${feature}_repository.dart':
        'abstract class ${pascal}Repository {\n  // Define repository contract\n}\n',
    'domain/usecases/get_$feature.dart':
        'class Get$pascal {\n  // Implement use case\n}\n',
    'data/datasources/${feature}_remote_datasource.dart':
        'class ${pascal}RemoteDataSource {\n  // TODO: Implement remote datasource\n}\n',
    'data/datasources/${feature}_local_datasource.dart':
        'class ${pascal}LocalDataSource {\n  // TODO: Implement local datasource\n}\n',
    'data/models/${feature}_model.dart':
        'class ${pascal}Model {\n  // TODO: Model implementation\n}\n',
    'data/repositories/${feature}_repository_impl.dart':
        'import "../../domain/repositories/${feature}_repository.dart";\n\nclass ${pascal}RepositoryImpl implements ${pascal}Repository {\n  // TODO: Implement repository\n}\n',
    'presentation/cubit/${feature}_state.dart':
        'sealed class ${pascal}State { const ${pascal}State(); }\nclass ${pascal}Initial extends ${pascal}State {}\n',
    'presentation/cubit/${feature}_cubit.dart':
        'import "${feature}_state.dart";\n\nclass ${pascal}Cubit {\n  ${pascal}State state = ${pascal}Initial();\n}\n',
    'presentation/pages/${feature}_page.dart':
        'import "package:flutter/widgets.dart";\n\nclass ${pascal}Page extends StatelessWidget {\n  const ${pascal}Page({super.key});\n  @override\n  Widget build(BuildContext context) => const SizedBox();\n}\n',
    'injection.dart':
        '// Hook to register dependencies for $feature\nvoid register${pascal}Dependencies() {\n  // TODO: GetIt registrations\n}\n',
    'README.md': '# $pascal Feature\n\nGenerated by teuton_feature.\n',
  };
}

/// Returns a file map for the "minimal" template of [feature].
Map<String, String> minimalTemplateFiles(String feature) {
  final pascal = toPascalCase(feature);
  return {
    'domain/entities/${feature}_entity.dart':
        'class ${pascal}Entity { const ${pascal}Entity(); }\n',
    'presentation/cubit/${feature}_state.dart':
        'sealed class ${pascal}State { const ${pascal}State(); }\n',
    'presentation/cubit/${feature}_cubit.dart': 'class ${pascal}Cubit {}\n',
  };
}
